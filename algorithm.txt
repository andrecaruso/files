Mechanics|Description|Score
Algorithm| A finite collection of unambiguous steps. Relying on the computational model. AHO (2012) spends six paragraphs explaining Turing Machines to further define algorithms in terms of them, just to point out how much detail is involved in precisely defining computation, even for one of the simplest models of computation. DENNING (2017) spots how the “new CT” movement has resignified algorithms, taking away the notion of the computational models. He argues that now algorithms are depicted as recipes for carrying out tasks, something for all kinds of information processors, including humans. In contrast to what it used to be: a set of directions to control a computational model, deriving their precision from it. Programs. We think the close relationship with the underlying computational model is best left for the word “program”, which we are going to define as an Algorithm so precisely defined that each of its steps are either a collection of other steps or a trivial instruction. By trivial instruction we mean one that is given, i.e. always easily, correctly understood and/or performed. Since what is trivial depends of the model, a program is always relative to the model. A programming language is a set of trivial instructions. We as computers. Following our definition of Computer, humans are perfectly fit for being classified as one. It might be nonviable to exhaustively map the full set of computations we are able to perform, yet, it would be enough to model a subset that covers what is needed for a given task. Thereafter, we would need to map those computations into trivial instructions the human is able to perform. At last, a programming language of a program for a human could be any restricted natural language, mimics or drawings in which the human is literate in and able to unambiguously interpret. Ambiguity. The major caveat with the process above (to formally use a human as a Computer carrying out Algorithms) is the difficulty of dealing with ambiguity. Probably the most distinctive force that shapes our minds in a certain way in CS is objectivity at its finest. Instructions and data are so precisely mapped into their meanings that a mechanical, mindless being can “understand” them, that there is no other way to do so. That is exactly the special touch Algorithms have, they are a special case of a composite instruction, an unambiguous one, which pervades all CS. Flow and Parallelism. When there is order in a collection of steps, it might express different shapes. A long sequence that starts over when it is finished is a cycle, if it pops out of another structure, it is a loop, each repetition is called an iteration. A sequence that branches into two or more is a conditional if it proceeds to one of its options, or a fork if it proceeds simultaneously to more. The whole dimension of parallelism is a matter of management of the flow of the steps. It comes with major concerns about different cadences, synchronization, resource dispute and locks (paths that are blocked due to their dependency of another). Although we consider recursion a form of Decomposition where the smaller parts share the same nature of the whole, it is often approached in the context of Algorithms we use to implement it. Algorithms in CS. From all the concepts addressed by CT, this is the one that needs less to justify its presence in CS. DENNING (2017) points out that names such as “algorithmizing” and “algorithmic thinking” were already used to address how CS changes the way one think prior to CS. Computer scientists assumed the challenge to make mindless beings perform complex tasks and it shaped the way they would envision, define and order instructions. A quest to eliminate intuition, subjectivity and ambiguity so those that have none of that (machines) could follow our orders. Additionally, multiple cores and huge distributed systems granted a place for concurrency on our instructions. our instructions. Examples. Figure 9 illustrates the main concepts discussed in this subsection: unambiguous steps, flow of control (including sequence, conditionals, cycle, loop and recursive processes), parallelism (including fork, join, synchronization, cadence, deadlock, resource dispute and coroutine), subroutine and iteration. In the sequence, a frame shows examples of what is included in the CT Line of Algorithm: (CTS) Topics such as mathematical induction (unambiguous steps and iteration) in math classes, interest (iteration and eventually recursive processes on compound interest) in economics classes and life, nitrogen and hydrologic cycles in biology and chemistry classes; (CTS) Expressions such as diagramming (flow of control) and multitasking (parallelism); and (CTS) Sensibility(ies) such as awareness of dependencies (resource dispute and deadlocks). Topics – Algorithm: ; (Computer Science) Flow of Control ; (Math) Mathematical Induction ; (Math) Polynomials Solving Process ; (Economics) Interest – Simple and Compound ; (Biology) Life Cycle ; (Biology/Chemistry) Nitrogen Cycle ; (Chemistry) Hydrologic Cycle ; (Physics) Multistaged Problems Expressions – Algorithm: ; Diagramming ; Multitasking Sensibilities – Algorithm: ; Awareness of Dependencies ; Recognizing Cycles.|0